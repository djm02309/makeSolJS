pragma solidity ^0.4.25;

contract RequiringAuthorization is Owned {
    mapping(address => bool) public authorized;

    modifier onlyAuthorized {
        require(authorized[msg.sender]);
        _;
    }

    constructor() internal {
        authorized[msg.sender] = true;
    }

    function authorize(address _address) public onlyAdmin {
        authorized[_address] = true;
    }

    function deauthorize(address _address) public onlyAdmin {
        authorized[_address] = false;
    }

}


contract Pausable is Owned {
    bool public paused = false;

    event Paused(bool _paused);

    modifier onlyPaused {
        require(paused == true);
        _;
    }

    modifier onlyActive {
        require(paused == false);
        _;
    }

    function pause() public onlyActive onlyAdmin {
        paused = true;
    }

    function activate() public onlyPaused onlyOwner {
        paused = false;
    }
}


contract BankWallet is Pausable, RequiringAuthorization, SafeMath {
    address public edgelessToken;
    address public edgelessCasino;

    uint public oneEdg = 100000;
    uint public maxFundAmount = 0.22 ether;

    event Withdrawal(address _token, uint _amount);
    event Deposit(address _receiver, uint _amount);
    event Fund(address _receiver, uint _amount);

    constructor(address _token, address _casino) public {
        edgelessToken = _token;
        edgelessCasino = _casino;
        owner = msg.sender;
    }

    function () public payable {}

    function withdraw(address _token, uint _amount) public onlyAdmin returns (bool _success) {
        _success = false;
        if (_token == address (0)) {
            uint weiAmount = _amount;
            if (weiAmount > address(this).balance) {
                return false;
            }
            _success = receiver.send(weiAmount);
        } else {
            Token __token = Token(_token);
            uint amount = _amount;
            if (amount > __token.balanceOf(this)) {
                return false;
            }
            _success = __token.transfer(receiver, amount);
        }

        if (_success) {
            emit Withdrawal(_token, _amount);
        }
    }

    function approve(uint _amount) public onlyAuthorized {
        _approveForCasino(edgelessCasino, _amount);
    }

    function deposit(address _address, uint _amount, bool _chargeGas) public onlyAuthorized {
        Casino __casino = Casino(edgelessCasino);
        __casino.deposit(_address, _amount, _chargeGas);
        emit Deposit(_address, _amount);
    }

    function fund(address _address, uint _amount) public onlyAuthorized returns (bool _success) {
        require(_amount <= maxFundAmount);
        _success = _address.send(_amount);
        if (_success) {
            emit Fund(_address, _amount);
        }
    }

    function setCasinoContract(address _casino) public onlyAdmin {
        edgelessCasino = _casino;
        _approveForCasino(_casino, 1000000000);
    }

    function setMaxFundAmount(uint _amount) public onlyAdmin {
        maxFundAmount = _amount;
    }

    function _approveForCasino(address _address, uint _amount) internal returns (bool _success) {
        Token __token = Token(edgelessToken);
        _success = __token.approve(_address, safeMul(_amount, oneEdg));
    }

}